# 文件上传

&nbsp;

## 文件解析漏洞

### 【IIS 5.x/6.0解析漏洞】

* **特殊后缀（iis6.0版本）**
  * a.asa，a.cer，a.cdx，a.asax，a.ascx，等后缀，在iis6.0中会以asp脚本形式运行

* **封号解析（iis6.0或之前版本）**
  * 条件：上传到服务器的文件名称不会改变
  * a.asp;.jpg，这个文件上传到服务器上会以asp脚本处理

* **目录解析（iis6.0或之前版本）**
  * 条件：有权限创建目录，一般搭配编辑器配合解析漏洞进行利用
  * /xx.asp/xx.jpg
  * 在网站下建立文件夹的名字为 .asp、.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。

### 【IIS 7.0/IIS 7.5/IIS8.0/8.5 /10.0解析漏洞】

* **通用匹配（iis7.0或之后版本版本）**
  * 条件：打开iis中的通用匹配时，可以使用
  * x.jpg/.php，此文件会以php格式脚本执行，而不是jpg

* **%00截断**
  * X.asp%00jieduan%jpg

* **第二种解析漏洞**
  * a.aspx.a;.a.aspx.jpg..jpg

### 【Apache解析漏洞】

* **后缀读取漏洞**
  * apache完整容器读取文件后缀会从最右边开始检测，如果不是正常的后缀时，会再向左走一个进行判断
  * x.php.zzzzzzs.ffffffffd，此文件会以php文件格式执行（一般用来过黑名单）
  * 必须是完整的apache，阉割的不行

* **特殊后缀**
  * phtml，php3，php4，php空格，php_，这些后缀会以php格式执行

* **htaccess文件解析**
  * 如果可以往服务器写入.htaccess文件，则可以开启后门，即指定某个文件以脚本形式运行
  * 如果在Apache中.htaccess可被执行.且可被上传.那可以尝试在.htaccess中写入: 
  <FilesMatch “*.jpg "> SetHandler application/x-httpd-php </FilesMatch>
  然后再上传shell.jpg的木马, 这样shell.jpg就可解析为php文件

### 【Nginx解析漏洞】

* **空字节代码执行漏洞（版本0.5，0.6，0.7<=0.7.65，0.8<=0.8.37）**
  * xxx.php%oo.jpg，此文件通过空字节绕过防御，以php格式执行

* **畸形解析漏洞**
  * 条件：默认fast-cgi开启
  * 在一个文件路径后面加上/xx.php，会将原来的文件解析为php文件

* **Nginx文件名逻辑漏洞(CVE-2013-4547)（版本0.8.41至1.4.3，和1.5.7之前的1.5.x版本）**
  * 正常上传一个附加代码的图片"test.jpg"，访问时后面+"空格"+"\0"+".php"，即让图片作为php文件解析

&nbsp;

## 上传突破

### 【文件上传过程】

* **找到上传页面**
  * 通过目录爆破，网页爬行，得出网站中有价值的页面，例如：upload.asp，up.html，upfile.asp，inc/，include/，admin/（管理员目录），editor，ewebeditor，ckeditor，ckfinder等等
  * 常见上传漏洞目录：upload/，inc/，include/，admin/   管理员目录，editor/，ewebeditor/，fckeditor/，ckfinder/
  * > 找不到上传页面，一定要扫二级目录，或者三级目录

  * 有时上传页面是空白，则有可能是接受页面，自己编写表单form最后提交的页面写成那个空白页面

* **文件上传的特征**

  * 请求Header中Content-Type存在以下特征：
    * multipart/form-data（表示该请求是一个文件上传请求）
    * 存在boundary字符串（作用为分隔符，以区分POST数据）
  * POST的内容存在以下特征：
    * Content-Disposition
    * name
    * filename
    * POST中的boundary的值就是Content-Type的值在最前面加了两个--，除了最后标识结束的boundary
    * 最后标识结束的boundary最后默认会多出两个--（测试时，最后一行的boundary删掉也能成功上传）

* **服务器命名规则**
  * 第一种类型：上传文件名和服务器命名一致
  * 第二种类型：上传文件名和服务器命名不一致（随机，时间日期命名等）

### 【常见上传检测方式】

* 前端js函数中拦截，检测文件扩展名
* 后端MIME类型，检测Content-Type
* 后端目录检测，即检测path相关参数
* 文件扩展名检测，黑白名单拦截
* 文件内容检测，waf检测是否有木马，和后缀

### 【客户端检测绕过(javascript 检测)】

* **首先判断JS本地验证**
  * 通常可以根据它的验证警告弹框的速度可以判断，如果你电脑运行比较快，那么我们可以用burp抓包，在点击提交的时候burp没有抓到包，就已经弹框那么说明这个就是本地js验证。

* **绕过方法**
  * 使用burp抓包改名
  * 使用firebug直接删除掉本地验证的js代码
  * 添加js验证的白名单如将php的格式添加进去

### 【服务端检测绕过(MIME 类型检测)】

* ** MIME的作用 **
  * 使客户端软件，区分不同种类的数据，例如web浏览器就是通过MIME类型来判断文件是GIF图片，还是可打印的PostScript文件。

* **绕过方法**
  * 直接使用burp抓包，得到post上传数据后，将 Content-Type: text/plain改成 Content-Type: image/gif就可以成功绕过。

### 【服务端检测绕过(目录路径检测)】

* **目录检测**
  * 使用burpsuit上传正确的文件类型，查看文件保存成什么类型，上传成功后，测试使用特殊后缀进行测试是否通过

* **绕过**
  * filepath参数，可以使用/a.asp;   绕过目录检测，最终目标文件保存为/a.asp;20200907.jpg，此时文件会以asp脚本执行，也可以使用%00进行截断
  * > 当上传后的目录中没有脚本执行权限，此时可以更换目录，即  /../a.asp

### 【服务端检测绕过(文件扩展名检测)】

* **黑名单绕过**
  * 文件名大小写绕过：用像 AsP，pHp 之类的文件名绕过黑名单检测
  * 名单列表绕过：用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类
  * 特殊文件名绕过：比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式 在 windows 系统里是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。
  * 0x00 截断绕过：在扩展名检测这一块目前我只遇到过 asp 的程序有这种漏洞，给个简单的伪代码 name = getname(http request) //假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00)
  * .htaccess：.htaccess 文件攻击 配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测SetHandler application/x-httpd-php （将jpg脚本转化为php）
  * 解析调用/漏洞绕过：这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞

* **白名单绕过**
  * 0x00 截断绕过：用像 test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑 漏洞进行攻击，目前我只遇到过 asp 的程序有这种漏洞
  * 解析调用/漏洞绕过：这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析调用/漏洞
  * .htaccess 文件攻击：通过一个.htaccess 文件调用 php 的解析器去解析一个文件名中只要包含"haha"这个字符串的 任意文件，所以无论文件名是什么样子，只要包含"haha"这个字符串，都可以被以 php 的方 式来解析，是不是相当邪恶，一个自定义的.htaccess 文件就可以以各种各样的方式去绕过很 多上传验证机制

* **双文件上传**
  * 使用burp拦截上传内容，在post中上传内容后再次添加一个文件内容，并且含有一句话木马，只要前一个文件内容中没有被拦截，则木马可以上传成功

* **竞争上传**
  * 基于上传文件后名称不改变
  * 利用多线程并发访问触发上传后的文件，让其生成一个webshell

### 【服务端检测绕过(文件内容检测)to do】

* **绕过检测文件头**
  * 主要是检测文件内容开始处的文件幻数

* **文件相关信息检测**
  * 图像文件相关信息检测常用的就是 getimagesize()函数 只需要把文件头部分伪造好就 ok 了，就是在幻数的基础上还加了一些文件信息 有点像下面的结构

* **文件加载检测**
  * 这个是最变态的检测了，一般是调用 API 或函数去进行文件加载测试 常见的是图像渲染测试，再变态点的甚至是进行二次渲染(后面会提到) 对渲染/加载测试的攻击方式是代码注入绕过 对二次渲染的攻击方式是攻击文件加载器自身

> 一般代码拦截只看文件后缀，但是waf拦截看文件上传banner

